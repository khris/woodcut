# MDF 재단 최적화 프로젝트

## 프로젝트 개요
MDF 원판(1220mm × 2440mm)에서 필요한 조각들을 최소한의 판으로 효율적으로 재단하는 최적화 도구

**핵심 제약사항:**
- Guillotine Cut만 가능 (일직선 절단, 중간에 멈출 수 없음)
- 톱날 두께(kerf): 5mm
- 회전 가능 (MDF라 결 무관)
- 테두리 손실: 각 변 5mm (원판 유효 크기: 1210mm × 2420mm, 90도 회전하여 사용)

## 현재 구현 상태

### 완성된 기능
1. **3가지 패킹 전략**
   - 정렬 우선 자유 공간 패킹 (빠름, 안정적)
   - 하이브리드 (높이 그룹 + 자유 공간) ⭐ 추천
   - 유전 알고리즘 (느림, 최적 탐색)

2. **2-Phase Guillotine Cut 알고리즘**
   - Phase 1: 차원 트리밍 (조각을 정확한 크기로 절단)
   - Phase 2: 조각 분리 (트림된 조각들을 개별 분리)
   - 재귀적 영역 분할로 복잡한 배치도 완벽 처리
   - 모든 조각이 정확한 크기로 절단됨 ✅

3. **시각화**
   - 조각 배치 표시 (색상으로 구분)
   - 절단선 표시 (빨강: 수평, 파랑: 수직)
   - 절단 순서 번호 표시
   - PNG 파일 저장

### 파일 구조
```
src/woodcut/__init__.py    # 메인 알고리즘
pyproject.toml              # uv 프로젝트 설정
AGENTS.md                   # 이 문서
README.md                   # 사용 가이드
```

## 핵심 알고리즘 설명

### 1. 패킹 단계
배치 전략에 따라 조각들을 원판에 배치
- **자유 공간 관리**: 남은 공간을 FreeSpace 객체로 추적
- **정렬 우선**: 기존 조각들과 x, y 좌표 일치하는 위치 선호
- **회전 결정**: 각 조각마다 원본/회전 중 더 효율적인 방향 선택
- **하이브리드 전략**: 최소 차원별로 그룹화하여 배치 효율 극대화

### 2. 절단선 생성 단계 (2-Phase Cutting)

#### Phase 1: 차원 트리밍 (Trimming Cuts)
```python
def _generate_trimming_cuts(region):
    # 같은 시작점(y)의 조각들을 그룹화
    y_groups = {}
    for piece in region.pieces:
        y_start = piece['y']
        y_groups[y_start].append(piece)

    # 각 그룹에서 최대 필요 높이로 절단선 생성
    for y_start, pieces_at_y in y_groups.items():
        max_req_h = max(piece['height'] for piece in pieces_at_y)
        cut_y = y_start + max_req_h

        # 우선순위: 1000 + 영향받는 조각 수
        # → 많은 조각을 동시에 트림하는 절단 우선
```

**핵심 아이디어:**
- 같은 y 좌표에서 시작하는 조각들 중 **가장 큰 높이**로 수평 절단
- 예: y=0에서 640×369와 800×310이 공존 → 먼저 y=369로 절단
- 그 다음 수직 절단으로 영역 분리
- 분리된 영역에서 800×310 조각을 y=310으로 추가 트림

#### Phase 2: 조각 분리 (Separation Cuts)
```python
def _generate_separation_cuts(region):
    # 조각 끝 + kerf 위치에 분리선 생성
    for piece in region.pieces:
        sep_y = piece['y'] + piece['height'] + kerf

        # 우선순위: min(위쪽 조각 수, 아래쪽 조각 수)
        # → 균형있게 분할하는 절단 우선
```

#### 절단 실행 및 재귀
```python
def _split_region(region, cuts, cut_order):
    # 1. 모든 조각이 정확한 크기면 종료
    if _all_pieces_exact(region):
        if len(region.pieces) <= 1:
            return

    # 2. 트리밍 + 분리 절단선 생성 및 우선순위 정렬
    all_cuts = sorted(
        trimming_cuts + separation_cuts,
        key=lambda c: (c['priority'], -c['position']),
        reverse=True
    )

    # 3. 최우선 절단 선택 및 실행
    best_cut = all_cuts[0]

    # 4. 조각들을 두 그룹으로 분류
    #    - 절단선을 가로지르는 조각: placed_h 업데이트 (트리밍)
    #    - 완전히 한쪽에 속하는 조각: 해당 영역으로 분류

    # 5. 하위 영역 생성 후 재귀
    _split_region(below_region, cuts, cut_order)
    _split_region(above_region, cuts, cut_order)
```

**중요 특징:**
1. **절단선은 현재 영역의 경계 내에서만** 그어짐 (Guillotine 제약)
2. **트리밍이 분리보다 우선** (priority 1000+ vs 낮은 값)
3. **조각 1개라도 트리밍 필요하면 절단 생성** (영역 크기 > 조각 크기)
4. **placed_w/h로 실제 절단 크기 추적** (배치 크기 ≠ 최종 크기)

### 3. 결과 검증
```python
def _all_pieces_exact(region):
    for piece in region.pieces:
        actual_w = piece['placed_w']
        actual_h = piece['placed_h']
        required_w = piece['height' if rotated else 'width']
        required_h = piece['width' if rotated else 'height']

        if abs(actual_w - required_w) > 1:  # 1mm 오차 허용
            return False
    return True
```

모든 조각이 정확한 크기(±1mm)로 절단되었는지 검증

### 4. 결과 평가
- 사용 판 개수 (최우선)
- 절단 횟수 (최소화)
- 공간 사용률
- **조각 정확도** (모든 조각이 정확한 크기인가?)

## 사용 방법

```bash
# CLI 실행
uv run woodcut

# 또는 빌드 후 실행
uv build
woodcut
```

입력 예시:
```python
pieces = [
    (800, 310, 2),   # 800×310 조각 2개
    (644, 310, 3),   # 644×310 조각 3개
    (371, 270, 4),   # 371×270 조각 4개
    (369, 640, 2),   # 369×640 조각 2개
]
```

출력:
- 콘솔: 절단 순서, 조각 크기 검증 결과
- PNG: 시각화 결과 (mdf_cutting_guillotine.png)

## 주요 개선 히스토리

1. ~~rectpack 사용~~ → 절단선 제어 불가
2. ~~행 우선 패킹~~ → 원판 회전 필요 깨달음
3. ~~높이별 그룹핑~~ → 공간 낭비 심함
4. ✅ **자유 공간 패킹** → 1장 성공!
5. ~~절단선 중간 끊김~~ → Guillotine 제약 이해
6. ~~전체 관통만~~ → 영역 분할 추적 필요
7. ✅ **재귀적 영역 분할** → 기본 구현 완료
8. ~~조각 크기 부정확~~ → placed_w/h 개념 부재
9. ~~같은 위치, 다른 높이 처리 실패~~ → 균형 기반 절단의 한계
10. ✅ **2-Phase Cutting 알고리즘** → 완벽! 모든 조각 정확한 크기로 절단 ⭐

## 알고리즘 동작 예시

### 예시: 371×270 조각 2개 (같은 y=689, x 좌표만 다름)

**기존 문제:**
- 두 조각 모두 y=689에서 시작, 높이 270 필요
- 하지만 절단이 y=310에서 발생하여 두 조각 모두 310 높이로 잘림 ❌

**2-Phase 해결:**
1. y=689에서 시작하는 조각들의 최대 높이: 270
2. **y=959 (689+270)에서 수평 절단** (트리밍, priority 1002)
3. 두 조각 모두 정확히 270 높이로 트림됨
4. 이후 수직 절단으로 개별 분리 (분리, priority 낮음)

### 예시: 640×369와 800×310이 y=0에서 공존

**문제 상황:**
- x=0~1285: 640×369 조각 2개 (높이 369 필요)
- x=1290~: 800×310 조각 1개 (높이 310 필요)
- 둘 다 y=0에서 시작

**2-Phase 해결:**
1. y=0 그룹의 최대 높이: 369
2. **y=369에서 수평 절단** (영역 전체를 369 높이로)
3. **x=1285에서 수직 절단** (좌: 640×369들, 우: 800×310 영역)
4. 우측 영역(1285,0 1155×369)에서:
   - 800×310 조각 1개만 존재
   - 필요 높이(310) < 영역 높이(369)
   - **y=310에서 수평 절단** (조각 1개라도 트리밍 필요)
5. 800×310 조각도 정확한 크기로 완성 ✅

## 알려진 제약사항

1. **배치는 자유롭지만 절단은 Guillotine**
   - 배치 단계에서는 Guillotine 제약 없음
   - 절단 생성 단계에서 가능한 절단선만 추출
   - **모든 절단은 현재 영역을 완전히 관통**해야 함

2. **최적성 보장 안 됨**
   - 하이브리드/유전 알고리즘도 휴리스틱
   - 11개 정도는 충분히 좋은 결과
   - 30~40개로 늘어나면 결과 품질 확인 필요

3. **현재는 조각 정확도 100% 달성**
   - 모든 조각이 ±1mm 오차 내로 절단됨
   - Guillotine Cut 제약 완벽 준수

## 확장 아이디어

1. **다양한 판 크기 지원**
   - 현재: 2420×1210 고정
   - TODO: 사용자 입력으로 변경

2. **절단 비용 모델링**
   - 현재: 모든 절단 동일 비용
   - TODO: 수평/수직 비용 차별화, 긴 절단 페널티

3. **배치 제약 추가**
   - TODO: 특정 조각 회전 금지
   - TODO: 결 방향 고려

4. **CLI/GUI 개선**
   - 현재: 코드 내 하드코딩
   - TODO: CSV 입력, JSON 출력

5. **실제 작업 가이드**
   - TODO: 절단 순서를 단계별 이미지로 출력
   - TODO: 조각별 라벨링 (스티커 출력용)

## 디버깅 팁

절단선이 이상하면:
1. 배치 결과 확인 (조각들이 Guillotine 가능한 패턴인가?)
2. `_generate_trimming_cuts` 로직 확인 (같은 시작점 그룹화)
3. `_split_region` 로직 확인 (우선순위 정렬, placed_w/h 업데이트)
4. 영역 경계 출력으로 재귀 추적

조각 크기가 부정확하면:
1. `placed_w/h` 업데이트 확인 (트리밍 절단 시)
2. 후처리 단계 확인 (미설정 조각 처리)
3. `_all_pieces_exact` 검증 로직 확인

성능 문제 시:
1. 조각 개수 확인 (50개 이상이면 느림)
2. 유전 알고리즘 파라미터 조정 (generations, population_size)
3. 간단한 전략(1번)으로 먼저 테스트

## 기술 스택
- Python 3.10+
- matplotlib (시각화)
- uv (패키지 관리 및 빌드)

## 핵심 개념 정리

### Guillotine Cut이란?
- 판 또는 **영역**을 완전히 관통하는 일직선 절단
- 중간에 멈추거나 꺾을 수 없음
- 한 번 자르면 두 개의 독립된 영역으로 분할됨

### 2-Phase Cutting의 장점
1. **트리밍 우선**: 조각을 정확한 크기로 만드는 것이 최우선
2. **같은 시작점 처리**: 여러 조각이 같은 위치에서 시작해도 최대 차원으로 처리
3. **조각 1개도 트림**: 영역 크기 > 조각 크기면 무조건 트리밍 절단 생성
4. **재귀적 분할**: 복잡한 배치도 영역별로 독립 처리

### placed_w/h vs width/height
- `width/height`: 조각의 원래 필요한 크기
- `placed_w/placed_h`: 절단 후 실제 크기 (트리밍 시점에 설정)
- 회전된 조각: `placed_w = height`, `placed_h = width`

## 문의사항
- 절단 시퀀스가 실제 작업과 맞지 않으면 Guillotine 제약 확인
- 공간 낭비가 심하면 하이브리드 전략(전략 2) 사용 권장
- 조각 크기가 부정확하면 이슈 리포트 (현재 버전은 100% 정확도 달성)
