# MDF 재단 최적화 프로젝트

## 프로젝트 개요
MDF 원판(1220mm × 2440mm)에서 필요한 조각들을 최소한의 판으로 효율적으로 재단하는 최적화 도구

**핵심 제약사항:**
- Guillotine Cut만 가능 (일직선 절단, 중간에 멈출 수 없음)
- 톱날 두께(kerf): 5mm
- 회전 가능 (MDF라 결 무관)
- 테두리 손실: 각 변 5mm (원판 유효 크기: 1210mm × 2420mm, 90도 회전하여 사용)

## 현재 구현 상태

### 완성된 기능
1. **3가지 패킹 전략**
   - 정렬 우선 자유 공간 패킹 (빠름, 안정적)
   - 하이브리드 (높이 그룹 + 자유 공간)
   - 유전 알고리즘 (느림, 최적 탐색) ⭐ 추천

2. **실제 Guillotine Cut 시퀀스 생성**
   - 절단 후 영역 분할 추적
   - 재귀적 영역 분할
   - 한번 자른 영역은 독립적으로 처리

3. **시각화**
   - 조각 배치 표시 (색상으로 구분)
   - 절단선 표시 (빨강: 수평, 파랑: 수직)
   - 절단 순서 번호 표시
   - PNG 파일 저장

### 파일 구조
```
mdf_cutting_guillotine.py  # 메인 스크립트 (uv run으로 실행)
mdf_cutting_guillotine.png # 결과 시각화
AGENTS.md                  # 이 문서
```

## 핵심 알고리즘 설명

### 1. 패킹 단계
배치 전략에 따라 조각들을 원판에 배치
- **자유 공간 관리**: 남은 공간을 FreeSpace 객체로 추적
- **정렬 우선**: 기존 조각들과 x, y 좌표 일치하는 위치 선호
- **회전 결정**: 각 조각마다 원본/회전 중 더 효율적인 방향 선택

### 2. 절단선 생성 단계 (핵심!)
```python
def generate_guillotine_cuts(plate):
    # 1. 루트 영역 생성 (전체 판)
    root_region = Region(0, 0, plate_width, plate_height)
    
    # 2. 재귀적으로 영역 분할
    _split_region(root_region, cuts, cut_order)

def _split_region(region, cuts, cut_order):
    # 조각이 1개 이하면 종료
    if len(region.pieces) <= 1:
        return
    
    # 영역 내 조각들의 경계에서 절단 후보 찾기
    # - 수평 절단: 위/아래로 완전 분리되는가?
    # - 수직 절단: 좌/우로 완전 분리되는가?
    
    # 가장 균형있게 분할하는 절단선 선택
    
    # 절단선 추가 (영역 범위 내에서만!)
    cuts.append({
        'position': y or x,
        'start': region.x or region.y,
        'end': region.x + region.width or region.y + region.height
    })
    
    # 하위 영역 생성 후 재귀
    _split_region(sub_region1, cuts, cut_order)
    _split_region(sub_region2, cuts, cut_order)
```

**중요:** 절단선은 현재 영역의 경계 내에서만 그어짐!

### 3. 결과 평가
- 사용 판 개수 (최우선)
- 절단 횟수 (최소화)
- 공간 사용률

## 사용 방법

```bash
uv run mdf_cutting_guillotine.py
```

입력 예시:
```python
pieces = [
    (800, 310, 2),   # 800×310 조각 2개
    (644, 310, 3),   # 644×310 조각 3개
    (371, 270, 4),   # 371×270 조각 4개
    (369, 640, 2),   # 369×640 조각 2개
]
```

출력:
- 콘솔: 절단 순서 상세 정보
- PNG: 시각화 결과

## 주요 개선 히스토리

1. ~~rectpack 사용~~ → 절단선 제어 불가
2. ~~행 우선 패킹~~ → 원판 회전 필요 깨달음
3. ~~높이별 그룹핑~~ → 공간 낭비 심함
4. ✅ **자유 공간 패킹** → 1장 성공!
5. ~~절단선 중간 끊김~~ → Guillotine 제약 이해
6. ~~전체 관통만~~ → 영역 분할 추적 필요
7. ✅ **재귀적 영역 분할** → 완벽!

## 알려진 제약사항

1. **배치는 자유롭지만 절단은 Guillotine**
   - 배치 단계에서는 Guillotine 제약 없음
   - 절단 생성 단계에서 가능한 절단선만 추출
   
2. **최적성 보장 안 됨**
   - 유전 알고리즘도 휴리스틱
   - 11개 정도는 충분히 좋은 결과
   - 30~40개로 늘어나면 결과 품질 확인 필요

## 확장 아이디어

1. **다양한 판 크기 지원**
   - 현재: 2420×1210 고정
   - TODO: 사용자 입력으로 변경

2. **절단 비용 모델링**
   - 현재: 모든 절단 동일 비용
   - TODO: 수평/수직 비용 차별화, 긴 절단 페널티

3. **배치 제약 추가**
   - TODO: 특정 조각 회전 금지
   - TODO: 결 방향 고려

4. **CLI/GUI 개선**
   - 현재: 코드 내 하드코딩
   - TODO: CSV 입력, JSON 출력

5. **실제 작업 가이드**
   - TODO: 절단 순서를 단계별 이미지로 출력
   - TODO: 조각별 라벨링 (스티커 출력용)

## 디버깅 팁

절단선이 이상하면:
1. 배치 결과 확인 (조각들이 Guillotine 가능한 패턴인가?)
2. `_split_region` 로직 확인 (완전 분리 조건 체크)
3. 영역 경계 출력으로 재귀 추적

성능 문제 시:
1. 조각 개수 확인 (50개 이상이면 느림)
2. 유전 알고리즘 파라미터 조정 (generations, population_size)
3. 간단한 전략(1번)으로 먼저 테스트

## 기술 스택
- Python 3.x
- matplotlib (시각화)
- uv (패키지 관리)

## 문의사항
- 절단 시퀀스가 실제 작업과 맞지 않으면 Guillotine 제약 확인
- 공간 낭비가 심하면 유전 알고리즘 파라미터 조정 또는 수동 배치 고려
